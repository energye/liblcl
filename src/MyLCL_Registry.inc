
//----------------------------------------
// The code is automatically generated by the GenlibLcl tool.
// Copyright Â© ying32. All Rights Reserved.
// 
// Licensed under Lazarus.modifiedLGPL
//
//----------------------------------------

function Registry_Create(AAccess: LongWord): TRegistry; extdecl;
begin
{$ifdef UsehandleException}Result := nil;{$endif}
  handleExceptionBegin
  Result :=  TRegistry.Create(AAccess);
  handleExceptionEnd
end;

procedure Registry_Free(AObj: TRegistry); extdecl;
begin
  handleExceptionBegin
  AObj.Free;
  handleExceptionEnd
end;

//CLASSMETHOD:
procedure Registry_CloseKey(AObj: TRegistry); extdecl;
begin
  handleExceptionBegin
  AObj.CloseKey;
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_CreateKey(AObj: TRegistry; Key: PChar): LongBool; extdecl;
begin
{$ifdef UsehandleException}Result := False;{$endif}
  handleExceptionBegin
  Result :=  AObj.CreateKey(Key);
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_DeleteKey(AObj: TRegistry; Key: PChar): LongBool; extdecl;
begin
{$ifdef UsehandleException}Result := False;{$endif}
  handleExceptionBegin
  Result :=  AObj.DeleteKey(Key);
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_DeleteValue(AObj: TRegistry; Name: PChar): LongBool; extdecl;
begin
{$ifdef UsehandleException}Result := False;{$endif}
  handleExceptionBegin
  Result :=  AObj.DeleteValue(Name);
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_HasSubKeys(AObj: TRegistry): LongBool; extdecl;
begin
{$ifdef UsehandleException}Result := False;{$endif}
  handleExceptionBegin
  Result :=  AObj.HasSubKeys;
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_KeyExists(AObj: TRegistry; Key: PChar): LongBool; extdecl;
begin
{$ifdef UsehandleException}Result := False;{$endif}
  handleExceptionBegin
  Result :=  AObj.KeyExists(Key);
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_LoadKey(AObj: TRegistry; Key: PChar; FileName: PChar): LongBool; extdecl;
begin
{$ifdef UsehandleException}Result := False;{$endif}
  handleExceptionBegin
  Result :=  AObj.LoadKey(Key, FileName);
  handleExceptionEnd
end;

//CLASSMETHOD:
procedure Registry_MoveKey(AObj: TRegistry; OldName: PChar; NewName: PChar; Delete: LongBool); extdecl;
begin
  handleExceptionBegin
  AObj.MoveKey(OldName, NewName, Delete);
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_OpenKey(AObj: TRegistry; Key: PChar; CanCreate: LongBool): LongBool; extdecl;
begin
{$ifdef UsehandleException}Result := False;{$endif}
  handleExceptionBegin
  Result :=  AObj.OpenKey(Key, CanCreate);
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_OpenKeyReadOnly(AObj: TRegistry; Key: PChar): LongBool; extdecl;
begin
{$ifdef UsehandleException}Result := False;{$endif}
  handleExceptionBegin
  Result :=  AObj.OpenKeyReadOnly(Key);
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_ReadBool(AObj: TRegistry; Name: PChar): LongBool; extdecl;
begin
{$ifdef UsehandleException}Result := False;{$endif}
  handleExceptionBegin
  Result :=  AObj.ReadBool(Name);
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_ReadDate(AObj: TRegistry; Name: PChar): TUnixDateTime; extdecl;
begin
{$ifdef UsehandleException}Result := 0;{$endif}
  handleExceptionBegin
  Result :=  ToUnixTime(AObj.ReadDate(Name));
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_ReadDateTime(AObj: TRegistry; Name: PChar): TUnixDateTime; extdecl;
begin
{$ifdef UsehandleException}Result := 0;{$endif}
  handleExceptionBegin
  Result :=  ToUnixTime(AObj.ReadDateTime(Name));
  handleExceptionEnd
end;

//CLASSMETHOD:
//RETURNISLASTPARAM:
procedure Registry_ReadFloat(AObj: TRegistry; Name: PChar; var Result: Double); extdecl;
begin
  handleExceptionBegin
  Result :=  AObj.ReadFloat(Name);
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_ReadInteger(AObj: TRegistry; Name: PChar): Integer; extdecl;
begin
{$ifdef UsehandleException}Result := Integer(0);{$endif}
  handleExceptionBegin
  Result :=  AObj.ReadInteger(Name);
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_ReadString(AObj: TRegistry; Name: PChar): PChar; extdecl;
begin
{$ifdef UsehandleException}Result := PChar(nil);{$endif}
  handleExceptionBegin
  Result :=  PChar(AObj.ReadString(Name));
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_ReadTime(AObj: TRegistry; Name: PChar): TUnixDateTime; extdecl;
begin
{$ifdef UsehandleException}Result := 0;{$endif}
  handleExceptionBegin
  Result :=  ToUnixTime(AObj.ReadTime(Name));
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_RegistryConnect(AObj: TRegistry; UNCName: PChar): LongBool; extdecl;
begin
{$ifdef UsehandleException}Result := False;{$endif}
  handleExceptionBegin
  Result :=  AObj.RegistryConnect(UNCName);
  handleExceptionEnd
end;

//CLASSMETHOD:
procedure Registry_RenameValue(AObj: TRegistry; OldName: PChar; NewName: PChar); extdecl;
begin
  handleExceptionBegin
  AObj.RenameValue(OldName, NewName);
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_ReplaceKey(AObj: TRegistry; Key: PChar; FileName: PChar; BackUpFileName: PChar): LongBool; extdecl;
begin
{$ifdef UsehandleException}Result := False;{$endif}
  handleExceptionBegin
  Result :=  AObj.ReplaceKey(Key, FileName, BackUpFileName);
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_RestoreKey(AObj: TRegistry; Key: PChar; FileName: PChar): LongBool; extdecl;
begin
{$ifdef UsehandleException}Result := False;{$endif}
  handleExceptionBegin
  Result :=  AObj.RestoreKey(Key, FileName);
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_SaveKey(AObj: TRegistry; Key: PChar; FileName: PChar): LongBool; extdecl;
begin
{$ifdef UsehandleException}Result := False;{$endif}
  handleExceptionBegin
  Result :=  AObj.SaveKey(Key, FileName);
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_UnLoadKey(AObj: TRegistry; Key: PChar): LongBool; extdecl;
begin
{$ifdef UsehandleException}Result := False;{$endif}
  handleExceptionBegin
  Result :=  AObj.UnLoadKey(Key);
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_ValueExists(AObj: TRegistry; Name: PChar): LongBool; extdecl;
begin
{$ifdef UsehandleException}Result := False;{$endif}
  handleExceptionBegin
  Result :=  AObj.ValueExists(Name);
  handleExceptionEnd
end;

//CLASSMETHOD:
procedure Registry_WriteBool(AObj: TRegistry; Name: PChar; Value: LongBool); extdecl;
begin
  handleExceptionBegin
  AObj.WriteBool(Name, Value);
  handleExceptionEnd
end;

//CLASSMETHOD:
procedure Registry_WriteDate(AObj: TRegistry; Name: PChar; Value: TUnixDateTime); extdecl;
begin
  handleExceptionBegin
  AObj.WriteDate(Name, UnixToTime(Value));
  handleExceptionEnd
end;

//CLASSMETHOD:
procedure Registry_WriteDateTime(AObj: TRegistry; Name: PChar; Value: TUnixDateTime); extdecl;
begin
  handleExceptionBegin
  AObj.WriteDateTime(Name, UnixToTime(Value));
  handleExceptionEnd
end;

//CLASSMETHOD:
//PARAMS:3=nonPtr
procedure Registry_WriteFloat(AObj: TRegistry; Name: PChar; var Value: Double); extdecl;
begin
  handleExceptionBegin
  AObj.WriteFloat(Name, Value);
  handleExceptionEnd
end;

//CLASSMETHOD:
procedure Registry_WriteInteger(AObj: TRegistry; Name: PChar; Value: Integer); extdecl;
begin
  handleExceptionBegin
  AObj.WriteInteger(Name, Value);
  handleExceptionEnd
end;

//CLASSMETHOD:
procedure Registry_WriteString(AObj: TRegistry; Name: PChar; Value: PChar); extdecl;
begin
  handleExceptionBegin
  AObj.WriteString(Name, Value);
  handleExceptionEnd
end;

//CLASSMETHOD:
procedure Registry_WriteExpandString(AObj: TRegistry; Name: PChar; Value: PChar); extdecl;
begin
  handleExceptionBegin
  AObj.WriteExpandString(Name, Value);
  handleExceptionEnd
end;

//CLASSMETHOD:
procedure Registry_WriteTime(AObj: TRegistry; Name: PChar; Value: TUnixDateTime); extdecl;
begin
  handleExceptionBegin
  AObj.WriteTime(Name, UnixToTime(Value));
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_ClassType(AObj: TRegistry): TClass; extdecl;
begin
{$ifdef UsehandleException}Result := TClass(nil);{$endif}
  handleExceptionBegin
  Result :=  AObj.ClassType;
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_ClassName(AObj: TRegistry): PChar; extdecl;
begin
{$ifdef UsehandleException}Result := nil;{$endif}
  handleExceptionBegin
  Result :=  ToPChar(AObj.ClassName);
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_InstanceSize(AObj: TRegistry): Integer; extdecl;
begin
{$ifdef UsehandleException}Result := Integer(0);{$endif}
  handleExceptionBegin
  Result :=  AObj.InstanceSize;
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_InheritsFrom(AObj: TRegistry; AClass: TClass): LongBool; extdecl;
begin
{$ifdef UsehandleException}Result := False;{$endif}
  handleExceptionBegin
  Result :=  AObj.InheritsFrom(AClass);
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_Equals(AObj: TRegistry; Obj: TObject): LongBool; extdecl;
begin
{$ifdef UsehandleException}Result := False;{$endif}
  handleExceptionBegin
  Result :=  AObj.Equals(Obj);
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_GetHashCode(AObj: TRegistry): Integer; extdecl;
begin
{$ifdef UsehandleException}Result := Integer(0);{$endif}
  handleExceptionBegin
  Result :=  AObj.GetHashCode;
  handleExceptionEnd
end;

//CLASSMETHOD:
function Registry_ToString(AObj: TRegistry): PChar; extdecl;
begin
{$ifdef UsehandleException}Result := PChar(nil);{$endif}
  handleExceptionBegin
  Result :=  PChar(AObj.ToString);
  handleExceptionEnd
end;

function Registry_GetCurrentKey(AObj: TRegistry): HKEY; extdecl;
begin
{$ifdef UsehandleException}Result := HKEY(0);{$endif}
  handleExceptionBegin
  Result :=  AObj.CurrentKey;
  handleExceptionEnd
end;

function Registry_GetCurrentPath(AObj: TRegistry): PChar; extdecl;
begin
{$ifdef UsehandleException}Result := PChar(nil);{$endif}
  handleExceptionBegin
  Result :=  PChar(AObj.CurrentPath);
  handleExceptionEnd
end;

function Registry_GetLazyWrite(AObj: TRegistry): LongBool; extdecl;
begin
{$ifdef UsehandleException}Result := False;{$endif}
  handleExceptionBegin
  Result :=  AObj.LazyWrite;
  handleExceptionEnd
end;

procedure Registry_SetLazyWrite(AObj: TRegistry; AValue: LongBool); extdecl;
begin
  handleExceptionBegin
  AObj.LazyWrite := AValue;
  handleExceptionEnd
end;

function Registry_GetLastError(AObj: TRegistry): Integer; extdecl;
begin
{$ifdef UsehandleException}Result := Integer(0);{$endif}
  handleExceptionBegin
  Result :=  AObj.LastError;
  handleExceptionEnd
end;

function Registry_GetLastErrorMsg(AObj: TRegistry): PChar; extdecl;
begin
{$ifdef UsehandleException}Result := PChar(nil);{$endif}
  handleExceptionBegin
  Result :=  PChar(AObj.LastErrorMsg);
  handleExceptionEnd
end;

function Registry_GetRootKey(AObj: TRegistry): HKEY; extdecl;
begin
{$ifdef UsehandleException}Result := HKEY(0);{$endif}
  handleExceptionBegin
  Result :=  AObj.RootKey;
  handleExceptionEnd
end;

procedure Registry_SetRootKey(AObj: TRegistry; AValue: HKEY); extdecl;
begin
  handleExceptionBegin
  AObj.RootKey := AValue;
  handleExceptionEnd
end;

function Registry_GetAccess(AObj: TRegistry): Cardinal; extdecl;
begin
{$ifdef UsehandleException}Result := Cardinal(0);{$endif}
  handleExceptionBegin
  Result :=  AObj.Access;
  handleExceptionEnd
end;

procedure Registry_SetAccess(AObj: TRegistry; AValue: Cardinal); extdecl;
begin
  handleExceptionBegin
  AObj.Access := AValue;
  handleExceptionEnd
end;

function Registry_StaticClassType: TClass; extdecl;
begin
  Result := TRegistry;
end;

exports
  Registry_Create,
  Registry_Free,
  Registry_CloseKey,
  Registry_CreateKey,
  Registry_DeleteKey,
  Registry_DeleteValue,
  Registry_HasSubKeys,
  Registry_KeyExists,
  Registry_LoadKey,
  Registry_MoveKey,
  Registry_OpenKey,
  Registry_OpenKeyReadOnly,
  Registry_ReadBool,
  Registry_ReadDate,
  Registry_ReadDateTime,
  Registry_ReadFloat,
  Registry_ReadInteger,
  Registry_ReadString,
  Registry_ReadTime,
  Registry_RegistryConnect,
  Registry_RenameValue,
  Registry_ReplaceKey,
  Registry_RestoreKey,
  Registry_SaveKey,
  Registry_UnLoadKey,
  Registry_ValueExists,
  Registry_WriteBool,
  Registry_WriteDate,
  Registry_WriteDateTime,
  Registry_WriteFloat,
  Registry_WriteInteger,
  Registry_WriteString,
  Registry_WriteExpandString,
  Registry_WriteTime,
  Registry_ClassType,
  Registry_ClassName,
  Registry_InstanceSize,
  Registry_InheritsFrom,
  Registry_Equals,
  Registry_GetHashCode,
  Registry_ToString,
  Registry_GetCurrentKey,
  Registry_GetCurrentPath,
  Registry_GetLazyWrite,
  Registry_SetLazyWrite,
  Registry_GetLastError,
  Registry_GetLastErrorMsg,
  Registry_GetRootKey,
  Registry_SetRootKey,
  Registry_GetAccess,
  Registry_SetAccess,
  Registry_StaticClassType;

